10 Sep 2022
Lecture - 1 
Notes:

String is a collection of zero or more characters written inside single or double quotes.
Characters:
    1) A-Z
    2) a-z
    3) 0-9
    4) $ & " ' whitespace (Special characters)

Example: "AabC" or 'AabC'

String creation:

1) using double quotes.
    let name = "Swati"

2) using single quotes (specific to JS).
    let name = 'Swati'

3) defined as objects with the keyword new:
    let name = new String("Swati");

    Not recommended. Do not create Strings objects.
    The new keyword complicates the code and slows down execution speed.
    String objects can produce unexpected results.

4) using Backticks
    Advantages:
        a) Easy String Concatination
        b) Do not need to escape single or double quotes
        c) Can write multiline without using the new line character


String Read:

let name = "Swati";
console.log(name);

String Update:

let name = "Swati";
name = "Avni";

String Delete:

let name = "Swati";
let name = "";

String Length:

Check the number of characters in string using "length" property.
Example:
    let name = "Swati";
    console.log(name.length); ---> 5

String vs Character Array:

let name = "Swati"; ---> String
let name_arr = ['S', 'w', 'a', 't', 'i'] ---> Character Array/Array of Strings

String Methods:
1) Substring
2) Slice
3) Replace
4) Concatination
5) Reverse

Text Justification

This is an example of text justification.
maxWidth = 16

This_ _ _ _is_ _ _ _an -> 10 empty spaces -> 6
6/2 = 3

example_ _of_text -> 15 empty spaces -> 1
1/2 = 0 -> no even spaces
1%2 = 1 -> left to right

3/2 = 1 -> at every valid position
3%2 = 1 -> left to right
example_ _ _of_ _text

justification. -> 14 empty spaces -> 2
justification._ _

division -> even number of spaces between words.
modulus -> leftover spaces that cannot be evenly distributed and has to be
in left to right fashion.

What must be acknowledgement shall be
maxWidth = 16

What must be -> 12 empty spaces = 4
4/2 = 2
What_ _ _must_ _ _be

acknowledgement -> 15 empty spaces = 1
acknowledgement_

shall be -> 8 empty spaces = 8
shall_ _ _ _ _ _ _ _ _be -> incorrect
shall be_ _ _ _ _ _ _ _ -> correct
shall be -> correct

Rules:
1) Even spaces have to be equally distributed among possibilities
2) Odd spaces have to placed from left to right
3) If there can be only one word in a line, all spaces will be at the end
4) last line is left unjustified


let name1 = "Swati";
console.log(name1);
let name2 = 'Swati';
console.log(name2);
let name3 = new String("Swati");
console.log(name3);
console.log(name1 === name2);
console.log(name3 === name2);
let address = 'Bengaluru';
//Hello Swati from Bengaluru
let message = "Hello " + name1 + " from " + address;
console.log(message);
//backtick
message = `Hello ${name1} from ${address}`;
console.log(message);
//Hello "Swati" from Bengaluru
message = `Hello "${name1}" from ${address}`;
console.log(message);
message = "Hello " + "\"" + name1 + "\"" + " from " + address;
console.log(message);
//Hello Swati
//from Bengaluru
message = "Hello " + name1 + "\nfrom " + address;
console.log(message);
console.log(message.length);
message = `Hello ${name1}
from ${address}`;
console.log(message);
name2 = 'Avni';
console.log(name2);
name2 = '';
console.log(name2);
console.log(name1.length);


Practice Question (Solution to be covered in the next lecture):

/**
 * Given an array of strings and a number(maxWidth), format the text such that
 * every line has exactly maxwidth characters and is both right and left aligned.
 *
 * Input:
 * 1. Array of strings/words
 * 2. A number/maxwidth
 *
 * Output:
 * Sentence printed on console with right and left justification.
 *
 * Sample:
 * ["This", "is", "an", "example", "of", "text", "justification."]
 * maxwidth = 16
 *
 * This____is____an
 * example__of_text
 * justification.__
 *
 * ["What", "must", "be", "acknowledgement", "shall", "be"]
 * maxwidth = 16
 *
 * What___must___be
 * acknowledgement_
 * shall_be________
 */
 

11 Sep 2022
Lecture - 2

Notes:

String Operations:

Length: The length property returns the length of a string:

Example:
let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
let length = txt.length;

charAt(): The charAt() method returns the character at a specified index (position) in a string:

Example:
let text = "HELLO WORLD";
let char = text.charAt(0);

Extracting String Parts:

There are 3 methods for extracting a part of a string:

1) slice(start, end): extracts a part of a string and returns the extracted part in a new string.
The method takes 2 parameters: the start position, and the end position (end not included).

Example:
Slice out a portion of a string from position 7 to position 13 (13 not included):
let str = "Lotus, Rose, Sunflower";
let part = str.slice(7, 13);
ans = "Rose, "

If a parameter is negative, the position is counted from the end of the string.
This example slices out a portion of a string from position -12 to position -6:
Example:
let str = "Lotus, Rose, Sunflower";
let part = str.slice(-12, -6);
ans = "e, Sun"

If you omit the second parameter, the method will slice out the rest of the string:
Example:
let str = "Lotus, Rose, Sunflower";
let part = str.slice(7);
ans = "Rose, Sunflower"

or, counting from the end:
Example:
let str = "Lotus, Rose, Sunflower";
let part = str.slice(-12);
ans = "e, Sunflower"

left to right -> positive numbers -> excludes the rightmost value
right to left -> negative numbers -> excludes the leftmost value

2) substring(start, end): The difference is that start and end values less than 0 are treated as 0 in substring().

The substring() method extracts characters, between two indices (positions), from a string, and returns the substring.
The substring() method extracts characters from start to end (exclusive).
The substring() method does not change the original string.
If start is greater than end, arguments are swapped: (4, 1) = (1, 4).
Start or end values less than 0, are treated as 0.

Example:
let str = "Lotus, Rose, Sunflower";
let part = str.substring(7, 13);
ans = "Rose, "

If you omit the second parameter, substring() will slice out the rest of the string.

3) substr(start, length): The difference is that the second parameter specifies the length of the extracted part.

The substr() method extracts a part of a string.
The substr() method begins at a specified position, and returns a specified number of characters.
The substr() method does not change the original string.
To extract characters from the end of the string, use a negative start position.

Example:
let str = "Lotus, Rose, Sunflower";
let part = str.substr(7, 6);

String Concatenation:

concat(): The concat() method joins two or more strings.
The concat() method does not change the existing strings.
The concat() method returns a new string.

Example:
let text1 = "Hello";
let text2 = "world";
let text3 = "Have a nice day";
let result = text1.concat(" ", text2, " ", text3);

indexOf(): The indexOf() method returns the position of the first occurrence of a value in a string.
The indexOf() method returns -1 if the value is not found.
The indexOf() method is case sensitive.

Parameters:
searchvalue: Required. The string to search for.
start: Optional. The position to start from (default is 0).

lastIndexOf(): The lastIndexOf() method returns the index (position) of the last occurrence of a specified value 
in a string. The lastIndexOf() method searches the string from the end to the beginning.
The lastIndexOf() method returns the index from the beginning (position 0).
The lastIndexOf() method returns -1 if the value is not found.
The lastIndexOf() method is case sensitive.


toLowerCase(): The toLowerCase() method converts a string to lowercase letters.
let text = "Hello World";
let result = text.toLowerCase();

toUpperCase(): The toUpperCase() method converts a string to uppercase letters.
let text = "Hello World";
let result = text.toUpperCase();

Practice Exercise - 1:

let text = "Hello World, Good Morning";
console.log(text.length); //25
console.log(text.charAt(2)); //l
/*let part = text.slice(2, 8);
console.log(part); //llo Wo
part = text.slice(-2, -8);
console.log(part);//blank
part = text.slice(-8, -2);
console.log(part);// Morni
part = text.slice(-8, 2);
console.log(part);//blank
part = text.slice(2, -8);//left to right
console.log(part);//llo World, Good
part = text.slice(-8);
console.log(part);// Morning
part = text.slice(2);
console.log(part);//llo World, Good Morning
part = text.slice(8, 2);
console.log(part); //blank
*/
/*
let part = text.substring(2, 8);
console.log(part);//llo Wo
part = text.substring(8, 2);
console.log(part);//llo Wo
part = text.substring(-2, -8);
console.log(part);//blank
part = text.substring(-8, -2);
console.log(part);//blank
part = text.substring(-8, 2);
console.log(part);//He
part = text.substring(2, -8);
console.log(part);//He
part = text.substring(-8);
console.log(part);//Hello World, Good Morning
part = text.substring(2);
console.log(part);//llo World, Good Morning
*/
/*
let part = text.substr(2, 8);
console.log(part);//llo Worl
part = text.substr(-2, -8);
console.log(part);//blank
part = text.substr(-8, -2);
console.log(part);//blank
part = text.substr(-8, 2);
console.log(part);// M
part = text.substr(2, -8);
console.log(part);//blank
part = text.substr(-8);
console.log(part);// Morning
part = text.substr(2);
console.log(part);//llo World, Good Morning
*/
let lowText = text.toLowerCase();
let upText = text.toUpperCase();
console.log(lowText.localeCompare(upText));
console.log(upText.localeCompare(lowText));
let text1 = "Hello World, Good Morning";
console.log(text.localeCompare(text1));

Practice Exercise - 2:
 
let text = "Hello World, Good Morning. ";
let result = text.concat("People", "\nin the", "Academy");
console.log(result);
console.log(text.indexOf('l'));//2
console.log(text.indexOf('l', 4));//9
console.log(text.indexOf('l', 10));//-1
console.log(text.lastIndexOf('l'));//9
console.log(text.lastIndexOf('l', 4));//3
console.log(text.lastIndexOf('l', 10));//9



12 Sep 2022
Lecture - 3

Text Justification Explanation and Solutions:

Explanation:

words = ["This", "is", "an", "example", "of", "text", "justification."]
maxwidth = 16

[This_ _ _ _,is_ _ _ _,an]
[example_ _,of_,text]
[justification._ _]

word = This
rem = 16 
temp = []
charCount = 4

word = is
rem = 16 - 1 - 4 = 11
temp = ["This"]
charCount = 6

word = an
temp = ["This", "is"]
rem = 16 - 2(spaces) - 6(charCount) = 8
charCount = 8

word = example
temp = ["This", "is", "an"] ----> first line
rem = 16 - 3 - 8 = 5

no of spaces for first line = 8

["This_ _ _ _", "is_ _ _ _", "an"]

word = example
rem = 16 
temp = []
charCount = 7

word = of
rem = 16 - 1 - 7 = 8
temp = ["example"]
charCount = 9

word = text
rem = 16 - 2 - 9 = 5
temp = ["example", "of"]
charCount = 13

word = justification.
rem = 16 - 3 - 13 = 0
temp = ["example", "of", "text"] ----> second line

["example_ _", "of_", "text"] 

word = justification.
rem = 16 
temp = []
charCount = 14

temp = ["justification."] ----> third line

["justification._ _"]

["shall", "be"]
shall_be_ _ _ _ _ _ _ _

Approach 1:

/**
 * Given an array of strings and a number(maxWidth), format the text such that
 * every line has exactly maxwidth characters and is both right and left aligned.
 *
 * Input:
 * 1. Array of strings/words
 * 2. A number/maxwidth
 *
 * Output:
 * Sentence printed on console with right and left justification.
 *
 * Sample:
 * ["This", "is", "an", "example", "of", "text", "justification."]
 * maxwidth = 16
 *
 * This____is____an
 * example__of_text
 * justification.__
 *
 * ["What", "must", "be", "acknowledgement", "shall", "be"]
 * maxwidth = 16
 *
 * What___must___be
 * acknowledgement_
 * shall_be________
 */
 
function justifyText(words, maxWidth){
    let answer = [];
    let temp = [];
    let charCount = 0;
    for(let i = 0; i<words.length; i++){
        let word = words[i];
        let remChars = maxWidth - (temp.length - 1) - charCount;
        if(word.length < remChars) {
            temp.push(word);
            charCount = charCount + word.length;
        } else {
            answer.push(padWhiteSpaces(temp, charCount, maxWidth).join(''));
            temp = [];
            temp.push(word);
            charCount = word.length;
        }
    }
    let numberOfWhiteSpaces = maxWidth - (temp.length - 1) - charCount;
    for(let i = 0; i < temp.length - 1; i++){
        temp[i] = temp[i] + '_';
    }
    while(numberOfWhiteSpaces > 0){
        temp[temp.length - 1] = temp[temp.length - 1] + '_';
        numberOfWhiteSpaces--;
    }
    answer.push(temp.join(''));
    return answer;
}
 
function padWhiteSpaces(temp, charCount, maxWidth){
    let numberOfWhiteSpaces = maxWidth - charCount;
    let i = 0;
    while(numberOfWhiteSpaces > 0){
        temp[i] = temp[i] + '_';
        numberOfWhiteSpaces--;
        i = i + 1;
        if(i == temp.length - 1) {
            i = 0;
        }
    }
    return temp;
}
 
console.log(justifyText(["This", "is", "an", "example", "of", "text", "justification."], 16));
console.log(justifyText(["What", "must", "be", "acknowledgement", "shall", "be"], 16));
 
 
/**
 * words = ["What", "must", "be", "acknowledgement", "shall", "be"]
 * charCount = 0 temp = []
 *  i      word       remChars    word.length<remChars  temp                    charCount   answer
 *  0      What        17          T                    [What]                      4
 *  1      must        12          T                    [What, must]                8
 *  2      be          7           T                    [What, must, be]            10
 *  3 acknowledgement  4           F                    [acknowledgement]           15      ['What___must___be']
 *  4   shall          1           F                    [shall]                     5       ['What___must___be', 'acknowledgement_']
 *  5     be           11          T                    [shall, be]                 7
 *  
 * after last line padding logic:
 *
 *  answer = [ 'What___must___be', 'acknowledgement_', 'shall_be________' ]
 *
 */
 
/**
 * [shall_, be_ _ _]
 */
 
/**
 * temp = ["This", "is", "an"] charCount = 8 maxWidth = 16
 * numberOfWhiteSpaces = 16 - 8 = 8
 * numberOfWhiteSpaces  numberOfWhiteSpaces > 0   i       temp[i]               i+1    (i == temp.length - 1)-> i+1 == 2
 *  8                            T                0     [This_, is, an]          1        F
 *  7                            T                1     [This_, is_, an]         2        T                
 *  6                            T                0     [This_ _, is_, an]       1        F
 *  5                            T                1     [This_ _, is_ _, an]
 *  
 *
 */





Approach 2:

function justifyText(words, L) {
    let lines = [], index = 0;
 
    while (index < words.length) {
        let count = words[index].length;
        let last = index + 1;
 
        while (last < words.length) {
            if (words[last].length + count + 1 > L) break;
            count += words[last].length + 1;
            last++;
        }
 
        let line = "";
        let difference = last - index - 1;
 
        // if we're on the last line or the number of words in the line is
        // 1, we left justify
        if (last === words.length || difference === 0) {
            for (let i = index; i < last; i++) {
                line += words[i] + "_";
            }
 
            line = line.substr(0, line.length - 1);
            for (let i = line.length; i < L; i++) {
                line += "_";
            }
        } else {
            // now we need to middle justify, which is putting equal amount
            // of spaces between words
            let spaces = (L - count) / difference;
            let remainder = (L - count) % difference;
 
            for (let i = index; i < last; i++) {
                line += words[i];
 
                if (i < last - 1) {
                    let limit = spaces + ((i - index) < remainder ? 1 : 0)
                    for (let j = 0; j <= limit; j++) {
                        line += "_";
                    }
                }
            }
        }
        lines.push(line);
        index = last;
    }
    return lines
}
 
console.log(justifyText(["This", "is", "an", "example", "of", "text", "justification."], 16));
console.log(justifyText(["What", "must", "be", "acknowledgement", "shall", "be"], 16));


13 Sep 2022
Lecture - 4

Notes:

String Comparisons in Javascript:

Ways of String Comparison (lexicographical):

1) Using localeCompare (recommended): 

It can be used to compare two strings in the current locale (language). Follows
lexicographical approach.

Syntax:
string1.localeCompare(string2)

localeCompare returns:
1 if string1 is greater (higher in the alphabetical order) than string2
-1 if string1 is smaller (lower in the alphabetical order) than string2
0 if string1 and string2 are equal in the alphabetical order

Important Point:
In some browsers, instead of -1, it may return -2 or some other negative value. 
So, do not depend on -1 or 1, instead on negative (less than 0) or positive (more than 0) values.

* lower case comes before upper case

2) Using Mathematical Operators: We can also use mathematical operators like greater than (>), less than (<), 
and equal to when comparing strings.
Mathematical operators work similarly to localeCompare – by returning results based on the order of the 
characters in the string.

return boolean values

* upper case comes before lower case

let string1 = "a";
let string2 = "A";
let compareValue = string1.localeCompare(string2);//-1
console.log(compareValue);
console.log(string1 < string2);//false

With mathematical operators, "a" is greater than "A", but with localeCompare, "a".localeCompare("A")" 
returns -1 to show that "a" is less than "A".
This is one reason why using mathematical operators for comparing strings is not recommended, 
even though it has the potential to do so.

Another reason using mathematical operators is not recommended is because "a" > "a" and "a" < "a" 
is false. "a" is equal to "a". So if you're depending on mathematical operators, getting false may 
be for different reasons than you believe.

So, for comparing strings, amongst the many ways there may be, using localeCompare is an effective approach 
because it can be used for different languages.

ASCII values:

a-z = 97 - 122
A-Z = 65 - 90
0-9 = 48 - 57

let string1 = "hello";
let string2 = "world";
let compareValue = string1.localeCompare(string2);
console.log(compareValue);//-1
string1 = "banana";
string2 = "back";
compareValue = string1.localeCompare(string2);
console.log(compareValue);//1
string1 = "fcc";
string2 = "fcc";
string3 = "Fcc";
let compareValue1 = string1.localeCompare(string2);
console.log(compareValue1);//0
let compareValue2 = string1.localeCompare(string3);
console.log(compareValue2);//-1
string1 = "hello";
string2 = "world";
console.log(string1 > string2);//false
string1 = "banana"
string2 = "back"
console.log(string1 > string2)//true
string1 = "ecc";
string2 = "fcc";
string3 = "Fcc";
console.log(string1 === string2);//true
console.log(string1 > string3);//true
console.log(string1.localeCompare(string3));//-1
string1 = "back";
string2 = "backend";
compareValue = string1.localeCompare(string2);
console.log(compareValue);//-1
console.log(string2 > string1);//true
string1 = "20";
string2 = "9";
console.log(string1.localeCompare(string2));//-1
console.log(string1 < string2);//true
//homework: explore special char comparison


String() function in Javascript:

The String() function is used to convert the value of an object to a string 
value.

Syntax:
String(object)

Parameter Values: 

object:This parameter contains a string which is converted to a string value.
Return Value: It returns a string value.

Escape characters:

These are characters that can be interpreted in some alternate way 
than what we intended to. To print these characters as it is, include backslash
‘\’ in front of them. 
Following are the escape characters in JavaScript −
Escape Sequences:

\" -> include double quote
\\ -> include backslash
\n -> new line
\r -> carriage return
\v -> vertical tab
\t -> horizontal tab
\b -> backspace
\f -> form feed

const a = 225;
const b = true;
let result1 = String(a);
console.log(result1);
let result2 = String(b);
console.log(result2);
console.log(typeof(a));//number
console.log(typeof(result1));//string
console.log(typeof(b));//boolean
console.log(typeof(result2));//string
let str1 = BigInt("1234567891234567891");
console.log(str1);
let str2 = String(str1);
console.log(str2);
str1 = 1234567891234567891n;
console.log(str1);
str2 = String(str1);
console.log(str2);

let name = 'My name is \'Swati\'.';
console.log(name);
name = 'My name is \"Swati\".';
console.log(name);
console.log(name.length);
name = 'My name is \nSwati.';
console.log(name);
console.log(name.length);
name = 'My name is \rSwati.';
console.log(name);
name = 'My name is \vSwati.';
console.log(name);
name = 'My name is \tSwati.';
console.log(name);
name = 'My name is \bSwati.';
console.log(name);
name = 'My name is \fSwati.';
console.log(name);
name = 'My name is \\Swati.';
console.log(name);
console.log(name.length);


String Operations:

trim(): removing whitespace from string.

split(): Convert string to an array.

Difference between two ways of Concatenation + and Concat():

1) The concat method would create new string object as output after appending 
only if output string has length greater than zero otherwise return the same 
target string as an output object.	
+ operator always create new object as output no matter what length of result 
string produced after appending.

2) Concat method returns null pointer exception in case this method called 
with null as input.	+ operator on the other hand do not throw any exception 
in a case called with null.

3) Performance	In the case of concat method as no new object is 
created if result string is of zero length hence it consumes lesser memory as 
compared to + operator.	While + operator always create a new object in the 
memory while appending the strings hence consumes more memory.

replace(): 
The replace() method searches a string for a value or a regular expression.
The replace() method returns a new string with the value(s) replaced.
The replace() method does not change the original string.

let text = "Visit Microsoft!";
let result = text.replace("Microsoft", "Amazon");

includes():
The includes() method returns true if a string contains a specified string.
Otherwise it returns false.
The includes() method is case sensitive.

Example:
let text = "Hello world";
let result = text.includes("world");

search():
The search() method matches a string against a regular expression **
The search() method returns the index (position) of the first match.
The search() method returns -1 if no match is found.
The search() method is case sensitive.

Example:
let text = "Hello World"
let position = text.search("World");

let text = ' Javascript     ';
console.log(text.trim());
console.log(text.split(' '));
let string1 = String('hello');
let string2 = String('world');
let result1 = null + string1;
console.log(result1);
//result1 = null.concat(string1); ---> exception
//console.log(result1);
result1 = string1.concat(null);
console.log(result1);
result1 = '' + string1;
console.log(result1);
let result2 = ''.concat(string1);
console.log(result2);
text = "Hello World";
let result = text.includes("world");
console.log(result);//false
result = text.includes("World");
console.log(result);//true
let position = text.search("world");
console.log(position);//-1
position = text.search("World");
console.log(position);//6


14 Sep 2022
Lecture - 5

Notes:

String Immutability:
Javascript String is immutable, which means once a String object is assigned to String reference the object 
value cannot be changed. However, we can still assign a new object to a String reference. This means that 
the characters within them may not be changed and that any operations on strings actually create new strings.

Example:
let string1 = "Hello World";
string1 = string1.toUpperCase();

After the first line the string1 will become "HELLO WORLD", but it still equals to "Hello World". 
The method will return a new String object it will not change the existing String reference. 
So we have to assign it to a new variable to get the desired value.
                       	string1
    |                       	    |
"Hello World"       "HELLO WORLD"

Note: We also cannot assign a new character to an index in String by square bracket notation. 
As Strings are immutable, by doing that we will be updating the content of String reference which cannot 
be possible in case of immutability.

let string1 = "Hello World";
string1[0] = "i";//still string1 remains same.

String object has many methods which deal with string characters and all of them returns a new String object 
instead of modifying the String object on which they are called.

Case-Sensitivity: String comparisons in Javascript are case-sensitive.

let string1 = "HEllO wOrld";
let string2 = "heLlO World";
(string1.toLowerCase()).LocaleCompare(string2.toLowerCase())
string1.toLowerCase() === string2.toLowerCase()

let string1 = "Hello World";
string1.toUpperCase();
console.log(string1);//Hello World
string1 = string1.toUpperCase();
console.log(string1);//HELLO WORLD
console.log(string1[1]);//E
string1[1] = "i";
console.log(string1[1]);//E

let a = 'a';
let b = 'A';
console.log(a == b);//false
console.log(a === b);//false
console.log(a == b.toLowerCase());//true
console.log(a === b.toLowerCase());//true

//multiline string using + and \ (backticks explained in lesson 1)
let message1 = 'Hello\n' + 'World';
let message2 = 'Hello\n\
World';
console.log(message1);
console.log(message2);
function justifyText(words, maxWidth) {
    let answer = [], index = 0;
 
    while (index < words.length) {
        let count = words[index].length;//4
        let last = index + 1;//1
 
        while (last < words.length) {
            if (words[last].length + count + 1 > maxWidth) break;
            count += words[last].length + 1;//10
            last++;//3
        }
 
        let line = "";
        let difference = last - index - 1;//2
 
        // if we're on the last line or the number of words in the line is
        // 1, we left justify
        if (last === words.length || difference === 0) {
            for (let i = index; i < last; i++) {
                line += words[i] + "_";
            }
            //below line is to ensure line length is not exceeding maxwidth.
            line = line.substr(0, line.length - 1);
            for (let i = line.length; i < maxWidth; i++) {
                line += "_";
            }
        } else {
            // now we need to middle justify, which is putting equal amount
            // of spaces between words
            let spaces = (maxWidth - count) / difference;//0.5 => 0
            let remainder = (maxWidth - count) % difference;//1
 
            for (let i = index; i < last; i++) {
                line += words[i];
 
                if (i < last - 1) {
                    let limit = spaces + ((i - index) < remainder ? 1 : 0)
                    for (let j = 0; j <= limit; j++) {
                        line += "_";
                    }
                }
            }
        }
        answer.push(line);
        index = last;
    }
    return answer
}
 
console.log(justifyText(["This", "is", "an", "example", "of", "text", "justification."], 16));
console.log(justifyText(["What", "must", "be", "acknowledgement", "shall", "be"], 16));
 
/**
 * ["This", "is", "an", "example", "of", "text", "justification."]
 *      index   count    last      difference  (maxWidth-count)/difference   %difference   line
 *        0      4        1
 *               7        2
 *               10       3
 *                                  2            6/2 = 3                      6%2 = 0      "This____is____an"
 *        3      7        4
 *               10       5
 *               15       6
 *                                  2                                                      example__
 *                
 *        
 */



15 Sep 2022
Lecture - 6

Longest Valid Parentheses:

Notes

Given a string containing just the characters '(' and ')', find the length of the 
longest valid (well-formed) parentheses substring.

Example 1:
Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".

Example 2:
Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".

Example 3:
Input: s = ""
Output: 0

Example 4:
Input: ((()
Output: 2
Explanation: ()

Example 5: 
Input: )()())
Output: 4
Explanation: ()() 

Example 6:
Input: ()(()))))
Output: 6
Explanation: ()(())

( ) ( ( ) ) ) ) )
0 1 2 3 4 5 6 7 8

isBalanced(str){ //----> O(n)
    return true/false
}

()((()(()(
arr = [(,(,(,(,(]

maxLen = 6

length = 2
(), )(, ((, (), )), ))

length = 3
()(, )((,......, )))

length = 4
( ) ( (, ) ( ( ), ( ( ) )

length = 6
( ) ( ( ) )

length = 8
( ) ( ( ) ) ) ) )

( ) ( (

left to right
open: 3
close: 1

right to left
open: 1
close: 1

left to right:
))))()

right to left:
()((((

maxLen = 0

left = 1
right = 0


( ) ( ( ) ) ) ) )
0 1 2 3 4 5 6 7 8

maxLen = 6

left to right:
open: 3
close: 3

set open and close to 0 when close > open

right to left:
open: 3
close: 6

set open and close to 0 when open > close

((((())()



Approach 1 (Brute Force):

function isBalanced(str){
    let arr = [];
    for(let i = 0; i<str.length; i++){
        if(str[i] === '(')
            arr.push(str[i]);
        else {
            if(arr.length !== 0)
                arr.pop();
            else
                return false;
        }
    }
    if(arr.length === 0)
        return true;
    return false;
}
 
function longestValidParentheses(str){
    let maxLen = 0;
    for(let i = 2; i<= str.length; i+=2){
        for(let j = 0; j <= str.length - i; j++){
            let val = str.substr(j, i);
            let isValid = isBalanced(val);
            if(isValid){
                maxLen = Math.max(maxLen, val.length);
            }
        }
    }
    return maxLen;
}
 
console.log(isBalanced("()(()))))"));
console.log(isBalanced("()(())"));
 
console.log(longestValidParentheses("((()"));
console.log(longestValidParentheses(")("));
console.log(longestValidParentheses(")))))"));
console.log(longestValidParentheses("()(())"));
console.log(longestValidParentheses("()(()))))"));
 

Approach 2 (Using Arrays):

function longestValidParentheses(str){
    let maxLen = 0;
    let arr = [];
    arr.push(-1);
    for(let i = 0; i<str.length; i++){
        if(str[i] === '('){
            arr.push(i);
        }
        else
        {
            arr.pop();
            if(arr.length === 0){
                arr.push(i);
            } else {
                maxLen = Math.max(maxLen, i - arr[arr.length - 1]);
            }
        }
    }
    return maxLen;
}
 
console.log(longestValidParentheses("((()"));
console.log(longestValidParentheses(")("));
console.log(longestValidParentheses(")))))"));
console.log(longestValidParentheses("()(())"));
console.log(longestValidParentheses("()(()))))"));


Approach 3 (Recommended : Without using arrays at all):

function longestValidParentheses(str){
    let maxLen = 0, open = 0, close = 0;
    for(let i = 0; i<str.length; i++){
        if(str[i] === '(')
            open++;
        else
            close++;
        if(open === close){
            maxLen = Math.max(maxLen, 2*open);
        }
        else if(close>open){
            open = close = 0;
        }
    }
    open = close = 0;
    for(let i = str.length - 1; i>=0; i--){
        if(str[i] === '(')
            open++;
        else
            close++;
        if(open === close){
            maxLen = Math.max(maxLen, 2*open);
        }
        else if(open>close){
            open = close = 0;
        }
    }
    return maxLen;
}
 
console.log(longestValidParentheses("((()"));
console.log(longestValidParentheses(")("));
console.log(longestValidParentheses(")))))"));
console.log(longestValidParentheses("()(())"));
console.log(longestValidParentheses("()(()))))"));


17 Sep 2022
Lecture - 7


Notes:

Maps:

Map is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of 
any type.

Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in the map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the value by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

Iteration over Map:

For looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.

Sets:

Collection of data items of any type.

Method	                Description

new Set()	            Creates a new Set
add()	                Adds a new element to the Set
delete()	            Removes an element from a Set
has()	                Returns true if a value exists
clear()	                Removes all elements from a Set
forEach()	            Invokes a callback for each element
values()	            Returns an Iterator with all the values in a Set
keys()	                Same as values()
entries()	            Returns an Iterator with the [value,value] pairs from a Set
Property	            Description
size	                Returns the number elements in a Set


Advantage of using Maps and Sets as a data structure is that lookup can be done in time complexity O(1).


let map = new Map();
 
map.set("1", "str1"); // a string key
map.set(1, "num1"); // a numeric key
map.set(true, "bool1"); // a boolean key
map.set("val", 1);
/**
 * {"1": "str1"},
 * {1: "num1"},
 * {}
 */
console.log(map);
console.log(map.get(1)); // 'num1'
console.log(map.get("1")); // 'str1'
 
console.log(map.size); // 3
 
map.set("val", map.get("val") + 1);
map.get("val");
map.set("val", 10);
map.get("val");
 
// iterate over keys
for (let key of map.keys()) {
  console.log(key);
}
/**
 *  key
 *  "1"
 *   1
 *  true
 */
 
// iterate over values
for (let val of map.values()) {
  console.log(val);
}
 
// iterate over [key, value] entries
for (let entry of map) {
  console.log(entry);
}
 
let map1 = new Map([
    ["apples", 500],
    ["oranges", 200]
]);
 
console.log(map1);
 




let set = new Set();
set.add(1);
set.add("2");
set.add(7);
console.log(set);
console.log(set.has("2"));
console.log(set.has(7));
console.log(set.has(5));
 
// iterate over keys
for (let key of set.keys()) {
  console.log(key);
}
 
for (let value of set.values()) {
  console.log(value);
}
 
for (let entry of set.entries()) {
  console.log(entry);
}


Usage of Map and Set:

Find the first number to finish a count of 3.

[2, 7, 1, -3, 8, 10, -3, -3, 1, 1]

Map

2 -> 1
7 -> 1
1 -> 1
-3 -> 3
8 -> 1
10 -> 1

Find the first pair that sums up to a sum.
 
[3, 5, 1, 8, 7, 10, 2]
Sum = 10
[3, 7]
[8, 2]

Set
3
5
1
8

[3, 7]



Valid Sudoku

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated 
according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.

Example 1:

Input: board = 
     0   1   2   3   4   5   6   7   8   
[0 ["5","3",".",".","7",".",".",".","."]
,1 ["6",".",".","1","9","5",".",".","."]
,2 [".","9","8",".",".",".",".","6","."]
,3 ["8",".",".",".","6",".",".",".","3"]
,4 ["4",".",".","8",".","3",".",".","1"]
,5 ["7",".",".",".","2",".",".",".","6"]
,6 [".","6",".",".",".",".","2","8","."]
,7 [".",".",".","4","1","9",".",".","5"]
,8 [".",".",".",".","8",".",".","7","9"]]

Output: true

     0   1   2  
[0 ["5","3","."]
,1 ["6",".","."]
,2 [".","9","8"]]

Beginning of 3X3 boxes:
[0, 0], [0, 3], [0, 6],
[3, 0], [3, 3], [3, 6],
[6, 0], [6, 3], [6, 6]

[2, 1] --> [0, 0]
startRow = row - row % 3 = 2 - 2%3 = 2 - 2 = 0
startCol = col - col % 3 = 1 - 1%3 = 0

[1, 4] --> start index of 3X3 box this is a part of in the sudoku --> [0, 3]
startRow = row - row % 3 = 1 - 1%3 = 0
startCol = col - col % 3 = 4 - 4%3 = 3

Example 2:

Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
 
Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit 1-9 or '.'.

Solution: 

function validateRow(board, row){
    let set = new Set();
    for(let i = 0; i<9; i++){
        if(set.has(board[row][i]))//false
            return false;
 
        if(board[row][i] != '.')
            set.add(board[row][i]);
    }
    return true;
}
/**
row = 2
set = {9, 8, 6}
    i    board[row][i]    set.has
    0    board[2][0]=.    false
    1    9                false
    2    8                false
 
 */
 
function validateCol(board, col){
    let set = new Set();
    for(let i = 0; i<9; i++){
        if(set.has(board[i][col]))
            return false;
 
        if(board[i][col] != '.')
            set.add(board[i][col]);
    }
    return true;
}
/**
 *
    col = 1
    set = {3, 9, 6}
 */
 
function validateBox(board, startRow, startCol){
    let set = new Set();
    for(let i = 0; i<3; i++){
        for(let j = 0; j<3; j++) {
            let val = board[i + startRow][j + startCol];
            if(set.has(val))
                return false;
 
            if(val != '.')
                set.add(val);
        }
    }
    return true;
}
/**
 * {5, 3, 6, 9, 8}
 * [3, 3]
 *      i   j      i+startRow      j+starCol
 *      0   0          3            3
 *      0   1          3            4
 *      1   0          4            3
 */
 
function isValid(board, row, col){
    return validateRow(board, row) && validateCol(board, col)
    && validateBox(board, row - row % 3, col - col % 3);
}
 
function isValidSudoku(board){
    for(let i = 0; i<9; i++){
        for(let j = 0; j<9; j++){
            if(!isValid(board, i, j))
                return false;
        }
    }
    return true;
}
//board1 -> [4, 3]
/*
validateRow -> {4, 8, 3, 1} -> true
validateCol -> {1, 8, 4} -> true
validateBox -> {6, 8, 3, 2} -> false
*/
let board1 =  
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2","8",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
 
console.log(isValidSudoku(board1));
 
let board2 =
[["5","3",".",".","7",".",".",".","."],
 ["6",".",".","1","9","5",".",".","."],
 [".","9","8",".",".",".",".","6","."],
 ["8",".",".",".","6",".",".",".","3"],
 ["4",".",".","8",".","3",".",".","1"],
 ["7",".",".",".","2",".",".",".","6"],
 [".","6",".",".",".",".","2","8","."],
 [".",".",".","4","1","9",".",".","5"],
 [".",".",".",".","8",".",".","7","9"]]
 
 console.log(isValidSudoku(board2));
 
 //Time Complexity when 9X9 = O(1)
 //Time Complexity when nXn = O(n^3)









18 Sep 2022
Lecture - 8

Hashing
Hashing is a technique or process of mapping keys, and values into the hash table by using a hash function. It is done for faster access to elements. The efficiency of mapping depends on the efficiency of the hash function used.
Let a hash function H(x) map the values at the index x%10 in an Array. For example, if the list of values is [11,12,13,14,15] it will be stored at positions {1,2,3,4,5} in the array or Hash table respectively.

Node {
        	Data: 21
        	Next: null
}
0
1      	11
2      	21
3      	13
4      	14
5      	15
6      	
Hash Functions:
The hash function in JavaScript is any function that takes input as arbitrary size data and
produces output as fixed-size data. Normally, the returned value of the hash function is
called hash code, hash, or hash value. Hash returns the fixed size,
which means that whatever size the input data is, a fixed size data will be received
after processing the input data with a hash function.
It is a complex mathematical calculation that takes an input (a.k.a. the key) (in this case the username of the member) and returns a value called a hash value or hash. When used for memory addressing the hash value generated is the memory location of where the record is stored.
Map.set(key, value)
h(key) = memory address
[value]
 |
Memory address
Map.get(key)
h(key) = memory address
Syntax of Hash Function:
function func(string)
{
//set variable hash as 0
var hash = 0;
.. . .. . .
return hash;
}
The result of a hash function is used as an index of the Hash Table.
hash table or hash map is a data structure that uses a hash function to map identifying values, known as keys (e.g., a person's name), to their associated values (e.g., their telephone number). Thus, a hash table implements an associative array. The hash function is used to transform the key into the index (the hash) of an array element (the slot or bucket) where the corresponding value is to be sought.
 
In computing, a hash table [hash map] is a data structure that provides virtually direct access to objects based on a key [a unique String or Integer]. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Here are the main features of the key used:
The key used can be your SSN, your telephone number, account number, etc
Must have unique keys
Each key is associated with–mapped to–a value
Hash buckets are used to apportion data items for sorting or lookup purposes. The aim of this work is to weaken the linked lists so that searching for a specific item can be accessed within a shorter time frame. 
A hash table that uses buckets is a combination of an array and a linked list. Each element in the array [the hash table] is a header for a linked list. All elements that hash into the same location will be stored in the list. The hash function assigns each record to the first slot within one of the buckets. In case the slot is occupied, then the bucket slots will be searched sequentially until an open slot is found. In case a bucket is completely full, the record will get stored in an overflow bucket of infinite capacity at the end of the table. All buckets share the same overflow bucket. However, a good implementation will use a hash function that distributes the records evenly among the buckets so that as few records as possible go into the overflow bucket.

 
Hash function constraints:
 
1. Deterministic: Suppose we input the same key, the same array index should be returned.
Math.random()
2. Fast: The hash function has to be used every time we create, read, update, or delete data. Therefore, the hash function should be fast, and moreover, it should not be connected to the existing data length. That is, O(1).
3. Uniform Distribution: if your size of hash-table is n and you push k (<n) elements to it, then, in every bucket of n/k in hash table,
there should be an element. Also, if k=r*c, in every bucket of size n/c in hash table, there should be r elements.
Obviously, perfect uniform distribution is not possible but output distribution should not be skewed.
[, 12, 14, 10, ,, , ]
0 1 2 3 4 5 6 7 8 9
4. Non-Invertible: The final important property of the hash function is the non-invertible property. It means, if a hash code is available, original data cannot be recovered without using a lot of resources for computing. Moreover, it cannot find original data.
That is, if a hash code h is available, value x cannot be found, that hash(x) = h.
 
 
HashTable Implementations
 
Implementation 1: (Storing keys and values together)

class HashTable {
    constructor() {
        this.table = new Array(127);
        this.size = 0;
    }
    _hash(key) {
        let hash = 0;
        for(let i = 0; i<key.length; i++){
            hash+= key.charCodeAt(i);
        }
        //console.log("Sum:", hash);
        return hash % this.table.length;
    }
    get(key){
        let hashCode = this._hash(key);
        return this.table[hashCode];
    }
    set(key, value){
        let hashCode = this._hash(key);
        let existingValue = this.get(key);
        this.table[hashCode] = [key, value];
        /*if(existingValue === undefined)
            this.size++;*/
        this.size = existingValue === undefined ? this.size + 1 : this.size;
    }
    remove(key){
        let hashCode = this._hash(key);
        //table[12] = [Canada, 300]
        //console.log(this.table[hashCode].length);//2
        if(this.table[hashCode].length) {
            this.table[hashCode] = [];
            this.size--;
            return true;
        } else {
            return false;
        }
    }
}
 
let ht = new HashTable();
ht.set("Canada", 300);
ht.set("France", 100);
ht.set("Spain", 110);
console.log(ht.table);
console.log(ht.get("France"));
ht.set("Canada", 400);
console.log(ht.get("Canada"));
console.log(ht.size);
console.log(ht.remove("Canada"));
console.log(ht.get("Canada"));
console.log(ht.remove("Canada"));
Implementation 2: (Storing only value at hashed value index)
class HashTable {
    constructor() {
        this.table = new Array(127);
        this.size = 0;
    }
    _hash(value) {
        let hash = 0;
        for(let i = 0; i<value.length; i++){
            hash+= value.charCodeAt(i);
        }
        //console.log("Sum:", hash);
        return hash % this.table.length;
    }
    get(value){
        let hashCode = this._hash(value);
        return this.table[hashCode];
    }
    set(value){
        let hashCode = this._hash(value);
        this.table[hashCode] = value;
        this.size++;
    }
    remove(value){
        let hashCode = this._hash(value);
        //table[12] = [Canada, 300]
        //console.log(this.table[hashCode].length);//2
        if(this.table[hashCode]) {
            this.table[hashCode] = undefined;
            this.size--;
            return true;
        } else {
            return false;
        }
    }
}
 
let ht = new HashTable();
ht.set("Canada");
ht.set("France");
ht.set("Spain");
console.log(ht.table);
console.log(ht.get("France"));
ht.set("Canada");
console.log(ht.get("Canada"));
console.log(ht.size);
console.log(ht.remove("Canada"));
console.log(ht.get("Canada"));
console.log(ht.remove("Canada"));

Implementation 3: (Storing value at hashed key index)
class HashTable {
    constructor() {
        this.table = new Array(127);
        this.size = 0;
    }
    _hash(key) {
        let hash = 0;
        for(let i = 0; i<key.length; i++){
            hash+= key.charCodeAt(i);
        }
        //console.log("Sum:", hash);
        return hash % this.table.length;
    }
    get(key){
        let hashCode = this._hash(key);
        return this.table[hashCode];
    }
    set(key, value){
        let hashCode = this._hash(key);
        this.table[hashCode] = value;
        this.size++;
    }
    remove(key){
        let hashCode = this._hash(key);
        //table[12] = [Canada, 300]
        //console.log(this.table[hashCode].length);//2
        if(this.table[hashCode]) {
            this.table[hashCode] = undefined;
            this.size--;
            return true;
        } else {
            return false;
        }
    }
}
 
let ht = new HashTable();
ht.set("Canada", 300);
ht.set("France", 100);
ht.set("Spain", 110);
console.log(ht.table);
console.log(ht.get("France"));
ht.set("Canada", 400);
console.log(ht.get("Canada"));
console.log(ht.size);
console.log(ht.remove("Canada"));
console.log(ht.get("Canada"));
console.log(ht.remove("Canada"));

 19 Sep 2022
Lecture - 9

Notes:

Differences between HashMap and Array:

1) Search on an array is O(n) while on a HashMap is O(1)
2) Arrays can have duplicate values, while HashMap cannot have duplicated keys (but they 
can have identical values.)

1 -> 1
2 -> 1


3) The Array has a key (index) that is always a number from 0 to max value, while in a 
HashMap, you have control of the key, and it can be whatever you want: number, string, or 
symbol.
 0  1  2  3
[1, 1, 1, 1]

HashMap Time Complexities:

Operation	                    Worst		Best	    Comments

Access/Search 
(HashMap.get)	    	  O(n)		O(1)	    O(n) is an extreme case when 
                                                    			   there are too many collisions
Insert/Edit (HashMap.set) O(n)		O(1)	    O(n) only happens with rehash when the 
                                                    			   Hash is 0.75 full
Delete (HashMap.delete)  O(n)		O(1)	    O(n) is an extreme case when too many								there are collisions
   

                                                 			

Sliding Window

Count distinct elements in every window of size k

Given an array of size N and an integer K, return the count of distinct numbers in all windows of 
size K. 

Examples: 

Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4
Output: 3 4 4 3
Explanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3
                      Second window is {2, 1, 3, 4} count of distinct numbers is 4
                      Third window is {1, 3, 4, 2} count of distinct numbers is 4
                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3

Input: arr[] = {1, 2, 4, 4}, K = 2
Output: 2 2 1
Explanation: First window is {1, 2}, count of distinct numbers is 2
                      First window is {2, 4}, count of distinct numbers is 2
                      First window is {4, 4}, count of distinct numbers is 1


Explanation:

arr = {1, 2, 1, 3, 4, 2, 3}, K = 4

{1, 2, 1, 3}
Map
1 -> 2
2 -> 1
3 -> 1
Map.size = 3

{2, 1, 3, 4}
Map
1 -> 1
2 -> 1
3 -> 1
4 -> 1
Map.size = 4

{1, 3, 4, 2}
Map
1 -> 1
2 -> 1
3 -> 1
4 -> 1
Map.size = 4

{3, 4, 2, 3}
Map
2 -> 1
3 -> 2
4 -> 1
Map.size = 3


function countDistinctElements(arr, k) {
    let map = new Map();
 
    for(let i = 0; i<k; i++){
        if(map.has(arr[i]))
            map.set(arr[i], map.get(arr[i]) + 1);
        else
            map.set(arr[i], 1);
    }
    console.log(map.size);
 
    for(let i = k; i<arr.length; i++) {
        if(map.get(arr[i - k]) == 1)
            map.delete(arr[i - k]);
        else
            map.set(arr[i - k], map.get(arr[i - k]) - 1);
 
        if(map.has(arr[i]))
            map.set(arr[i], map.get(arr[i]) + 1);
        else
            map.set(arr[i], 1);
       
        console.log(map.size);
    }
}
 
countDistinctElements([1, 2, 1, 3, 4, 2, 3], 4);
countDistinctElements([1, 2, 4, 4], 2);
 
/**
 * [1, 2, 1, 3, 4, 2, 3], k = 4
 *  0  1  2  3  4  5  6
 *
 * window 1 -> [1, 2, 1, 3] -> 0-3
 *              0  1  2  3
 * window 2 -> [2, 1, 3, 4]
 *              1  2  3  4
 * Map:
 * 3 -> 2
 * 4 -> 1
 * 2 -> 1
 *
 *         i   arr[i]  map.get(arr[i-k])==1  if(map.has(arr[i]))  map.size
 *         0    1                                   F
 *         1    2                                   F
 *         2    1                                   T
 *         3    3                                   F
 *         4                                                         3
 *
 *         4    4          F                        F                4
 *         5    2          T                        F                4
 *         6    3          T                        T                3
 */



 
 
 
 

